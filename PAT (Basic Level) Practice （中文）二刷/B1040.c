/*PTA B1040/1039
思考
	- 直接用暴力会超时
	- 换个角度思考问题,对一个确定位置的A来说,以它形成的PAT的个数等于它左边P的个数乘以它右边T的个数。
	- 例如对字符串APPAPT的中间那个A来说,它左边有两个P,右边有一个T,因此这个A能形成的PAT的个数就是2x1=2。
	- 于是问题就转换为,对字符串中的每个A,计算它左边P的个数与它右边T的个数的乘积,
	- 然后把所有A的这个乘积相加就是答案。
	- 所以，只需要设定一个数组left,记录每一位左边P的个数(含当前位,下同)。
	- 接着从左到右遍历字符串,如果当前位i是P,那么left[i]就等于left[i-_1]加1:
	- 如果当前位i不是P,那么left[i]就等于left[i-L1]1。
	- 于是只需要O(len)的时间复杂度就能统计出left数组。
	- 以同样的方法可以计算出每一位右边T的个数。
	- 为了节省代码量,不妨在统计每一位右边T的个数的过程中直接计算答案sum，具体做法是:
	- 定义一个变量right,记录当前累计右边T的个数。
	- 从右往左遍历字符串,如果当前位i是T,那么令right加1;
	- 否则,如果当前位1是A,那么令sum加上left[i]与right的乘积(注意取模)。
	- 这样,当遍历完字符串时,就得到了答案sum。
注意点
	1. 采用分别遍历P、A、T的位置来统计的方法会超时。
	2. 记得取模。
	3. 本题与PATB1045/A1101的思路很像,注意认真体会这两道题的思想。
*/
#include <stdio.h>
int main(){
	char str[100010];
	int i,left[100010]={0};	//每一位左边含P的个数
	gets(str);	 //读入字符串 
	int len=strlen(str); //长度
	for(i=0;i<len;i++){
		if(i>0)	left[i]=left[i-1]; //继承上一位的位置
		if(str[i]=='P')	left[i]++; 
	} 
	int sum=0,right=0; //sum为答案，right记录右边T的个数 
	for(i=len-1;i>=0;i--){
		if(str[i]=='T'){
			right++;
		} else if(str[i]=='A'){
			sum=(sum+left[i]*right)%1000000007; //累计乘积 
		}
	}
	printf("%d\n",sum); 
	return 0;
}

